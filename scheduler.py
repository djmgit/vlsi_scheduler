import json
import os

ocg_json = json.loads(open("ocg.json").read())

ocg_graph = ocg_json["graph"]
total_ops = ocg_json['total_ops']
csteps_estimate = ocg_json['csteps_estimate']
last_op = total_ops - 1
op_types = ocg_json['op_types']
var_type = ocg_json['var_type']

# method to get start time of an operation

def get_start_time(op):
	start_time = []
	for cstep in range(1, csteps_estimate):
	    start_time_term = "{} * x_{}{}".format(cstep, op, cstep)
	    start_time.append(start_time_term)
	start_time = " + ".join(start_time)
	return start_time

# method to formulate instance/resource contsraint for a given cstep

def get_instance_constraint(cstep):
	opr_constraint = []
	for opr in op_types.keys():
		ops = op_types[opr]
		opr_constraint_n = []
		for op in ops:
			opr_constraint_n_term = "x_{}{}".format(op, cstep)
			opr_constraint_n.append(opr_constraint_n_term)
		opr_constraint_n = " + ".join(opr_constraint_n)
		opr_constraint_n += " <= 1;"
		opr_constraint.append(opr_constraint_n)
	opr_constraint = "\n".join(opr_constraint)
	return opr_constraint

# formulating objective function

obj_fun = get_start_time(last_op)
obj_fun = "min: " + obj_fun + ";"

# formulating start time constraint

start_time_constraint = []

for op in range(0, total_ops):
	op_time_constraint = []
	for cstep in range(0, csteps_estimate):
		op_time_constraint_term = "x_{}{}".format(op, cstep)
		op_time_constraint.append(op_time_constraint_term)
	op_time_constraint = " + ".join(op_time_constraint)
	op_time_constraint = op_time_constraint + " = 1;"
	start_time_constraint.append(op_time_constraint)

start_time_constraint = "\n".join(start_time_constraint)

# formulating propagation delay and dependency constraint
# As of now it has been assumed that propagation delay is 1 for all operaion

dstep_constraint = []

for op in ocg_graph.keys():
	dependent_ops = ocg_graph[op]
	for dependent_op in dependent_ops:
		dstep_constraint_term = get_start_time(dependent_op) + " - " + get_start_time(op).replace("+", "-") + " - 1 >= 0;"
		#print get_start_time(op)
		dstep_constraint.append(dstep_constraint_term)

dstep_constraint = "\n".join(dstep_constraint)

# formulating resource contraint
# it has been assumed that number of resource for all resource types is 1
# this can be changes easily by modifying json file and changing a constant here
# will be made more flexible later

opr_constraints = []
for cstep in range(0, csteps_estimate):
	opr_constraint = get_instance_constraint(cstep)
	opr_constraints.append(opr_constraint)

opr_constraints = "\n\n".join(opr_constraints)

# listing all variables as it is neccesary for lp solve

var_list = []
for op in range(0, total_ops):
	for cstep in range(0, csteps_estimate):
		var_list_term = "x_{}{}".format(op, cstep)
		var_list.append(var_list_term)
var_list = ", ".join(var_list)
var_list += ";"

# listing all the constraints

obj_fun_and_constraints = [obj_fun, start_time_constraint, dstep_constraint, opr_constraints, var_type, var_list]

obj_fun_and_constraints = "\n\n".join(obj_fun_and_constraints)

lp_model = open("lp_model.txt", 'w')
lp_model.write(obj_fun_and_constraints + '\n')
lp_model.close()

print 'Model generated and stored in {}'.format('lp_model.txt')
print 'Running lp_solver on lp_model.txt...'

# Running lp_solve on model created

os.system("lp_solve lp_model.txt > lp_output.txt")
print 'Processing output file generated by lp_solver...'
print '\n'

# processing output generated by lp_solve

def process_output(output):
	lines = output[4:]
	
	sol = []
	for line in lines:
		if line == '':
			continue
		soln = line.split()
		if soln[1] == '1':
			sol.append(soln[0])

	final_sol = []
	for var in sol:
		final_sol.append('Operation {} should be scheduled on {} cstep'.format(var[2], var[3]))

	final_sol = "\n\n".join(final_sol)
	
	output = open('output.txt', 'w')
	output.write(final_sol + '\n')

	print final_sol
	print '\n'

output = open('lp_output.txt').readlines()
process_output(output)
os.system('rm lp_output.txt')

print 'Processing completed'
print 'Outpput stored in output.txt'
